---
layout: post
title: "MobX를 통한 상태 관리"
author: cupjoo
categories: [MobX]
image: assets/images/2020-03-07/1.png
---

[인스타그램 클론으로 배우는 프론트엔드 로드맵](https://cupjoo.github.io/인스타그램-클론으로-배우는-프론트엔드-로드맵)

---

## MobX가 뭐지?

MobX는 Redux와 더불어 리액트에서 제일 많이 사용되는 `상태 관리 라이브러리`이다. MobX는 리액트에 종속되지 않고 Pure Javascript에서도 사용가능한 라이브러리이지만, 탄생 배경은 React 같은 라이브러리들이 발전하면서 생겨난 것으로 볼 수 있다.

리액트는 중복되는 코드를 줄이고, 부분적으로 변화하는 파트만 re-rendering이 되도록 각 파트를 컴포넌트화하고 세분화해왔다. 그러다 보니 점점 리액트만으로는 컴포넌트 별로 공유하는 데이터들의 일관성을 유지하기 힘들어졌는데, MobX는 이런 상태 관리 및 업데이트 로직을 분리해 모듈화하여 유지보수성을 높여주는 역할을 한다.

물론 기존에도 Redux를 통한 상태관리가 대세를 이루었지만, Redux의 높은 진입장벽으로 인해 많은 사람들이 어려움을 겪었는데, MobX의 경우 문법이나 사용 난이도 자체가 몇 배는 쉽고 가벼워 MobX를 선택하게 되었다. 나도 실제로 사용해보니 하루 만에 익히게 되어 그 차이가 체감이 됐다.

## MobX의 핵심 컨셉

MobX의 핵심 컨셉은 크게 4가지로 나뉜다.

### Obserable State

말 그대로 관찰할 수 있는 상태 (= 관찰받는 상태)를 말한다. 해당 상태에서는 변화가 일어나면 바로 탐지가 가능해, 앞으로 설명할 Computed Value, Reactions 등의 기능을 수행하는데 필수적 요소다. `observable` 함수로 표현한다.

### Computed Value

기존 상태값 또는 다른 연산 값에 기반해 연산된 값을 말한다. 해당 값은 호출 시마다 연산이 이루어지는 것이 아니라, 기반 값이 바뀌었을 때 미리 연산된 뒤, 호출 시에는 해당 캐시값을 불러오는 것으로 동작이 이루어진다.

도서 대여 시스템을 예로 들면, 현재 장바구니에 대여할 책들의 수량을 변경할 때 총 수량은 변수로 갖고 있는 것보다 Computed Value로 필요할 때만 연산해 캐시로 가지고 있는 것이 낫다.

`computed`와 `observe` 함수로 표현하는데, `observe`의 경우 `autorun` 함수로 대체 가능하다.

### Reactions

지정한 Observable Value에 변동이 생겼을 때 호출되는 동작을 말한다. 값의 변동이 생길 시 Computed Value는 특정 값을 연산하지만 Reactions는 특정 행위를 수행한다는 점에서 차이가 있다. `reactions` 함수로 표현하는데, 마찬가지로 `autorun` 함수로 대체 가능하다.

### Actions

상태 (Observable Value)에 변화를 일으키는 것을 말한다. 즉 사용자가 버튼을 누르는 것처럼 어떤 행위를 수행 시 특정 함수를 통해 상태를 변화시키면 이는 Actions에 속한다. Reactions는 값이 변했을 때 호출되는 반면 actions는 사용자 행위에 의해 값을 변화시키기 위해 호출된다는 점에서 차이가 있다. `action` 함수로 표현한다.

## MobX Feature

백문이 불여일견, 직접 MobX 샘플 코드를 살펴보면 바로 이해가 된다.

```javascript
import { 
  observable, computed, autorun, action, transaction
} from 'mobx';

class Library {
  @observable basket = [];

  @computed
  get total() {
    return this.basket.reduce(
      (prev, curr) => prev+curr.fee, 0
    );
  }

  @action
  select(name, fee) {
    this.basket.push({ name, fee });
  }
}

const lib = new Library();
autorun(() => lib.total);

// reaction 정의
autorun(() => {
  if (lib.basket.length > 0) {
    console.log(lib.basket[lib.basket.length-1]);
  }
});

// actions 발생시킴
transaction(() => {
  lib.select('물', 800);
  lib.select('물', 800);
  lib.select('포카칩', 1500);
});

// computed value 요청
console.log(lib.total);
```

### Transaction

`transaction`은 actions를 묶어 한 번에 일으킬 때 사용된다. 연달아 여러 번 값이 변동되는 경우 매번 reactions나 computed value를 수행하기보다 한 번에 처리하기 위해 사용한다.

## 리액트에 MobX 적용하기

리액트에 MobX를 적용 시 상태 관리 로직은 컴포넌트로부터 분리되어, 스토어에서 따로 관리되게 된다.

- Component : UI와 Interactions만 관리
- Store : 상태 관련 로직

따라서 우리가 위에서 배운 MobX의 핵심 개념 등은 스토어에서 구현하면 되고, Redux와 다르게 MobX에서는 한 앱에 여러 개의 스토어를 가질 수 있다.

그럼 기본적인 컨셉은 파악했으니 이제 예시로 컨퍼런스 예약 사이트를 만들어 리액트 환경에 MobX를 적용해보기로 하자. 우선 프로젝트에 mobx 관련 패키지를 추가하자.

```bash
$ cd {project-directory}
$ yarn add mobx mobx-react
```

실습에서 사용할 프로젝트 기본 구조는 [기존 프로젝트](https://github.com/cupjoo/course-registration/tree/8b112228d3f1c3cd7eccc88e075dc7b8424f572e)에서 가져오자.

![2.png]({{ site.baseurl }}/assets/images/2020-03-07/2.png)

리액트 컴포넌트들로 UI만 구성한 상태다. 여기에 스토어를 추가해보자.

### Decorator 설정

시작하기에 앞서, MobX를 사용하다 보면 [Decorator](https://cupjoo.github.io/리액트-시작을-위한-ES7#decorator)를 많이 사용하는데 이를 위해 우리는 Babel 설정을 커스터마이징해야 한다. 하지만 CRA (Create React App)로 빌드한 프로젝트에서는 웹팩, 바벨 등의 설정이 숨겨져 있어 `yarn eject`를 하거나 CRA Customzing 라이브러리인 `customize-cra`와 `react-app-rewired`를 추가로 설치해야 한다. 우리는 후자를 선택해 진행하겠다.

```bash
$ yarn add --dev customize-cra react-app-rewired
$ yarn add --dev core-decorators
```

의존성 설치가 완료 되면 다음 파일들을 수정하자.

**package.json**

```javascript
  "scripts": {
    "start": "react-app-rewired start",
    "build": "react-app-rewired build",
    "test": "react-app-rewired test --env=jsdom",
    "eject": "react-scripts eject"
  },
  "babel": {
    "presets": [
      "react-app"
    ],
    "plugins": [
      ["@babel/plugin-proposal-decorators", { "legacy": true}],
      ["@babel/plugin-proposal-class-properties", { "loose": true}]
    ]
  }
```

**config-overrides.js (생성)**

```javascript
const { 
  addDecoratorsLegacy, // decorator를 사용할 수 있도록 해주는 config
  disableEsLint,
  override,
} = require("customize-cra");

// 사용자 정의 웹팩 설정
module.exports = {
  webpack: override(
      disableEsLint(),
      addDecoratorsLegacy()
  ),
};
```

### 1. 스토어 생성

이제 상태 로직은 모두 register 스토어에서 관리한다.

**src/store/register.js**

```javascript
import { observable, action, computed } from 'mobx';

export default class RegisterStore {
  @observable selectedItems = [];
  @observable courseItems = [
    {
      title: "인스타그램 클론으로 배우는 프론트엔드 테크닉",
      img: "instagram.png",
      startDate: "2020/01/01",
      endDate: "2020/01/30",
      lecturer: "쌍문동 파퀴아오"
    },
    {
      title: "MobX를 통한 상태관리 정복하기!",
      img: "mobx.png",
      startDate: "2020/02/01",
      endDate: "2020/02/30",
      lecturer: "노원구 피바다"
    },
    {
      title: "리액트 시작을 위한 ES7 (기초반)",
      img: "es7.png",
      startDate: "2020/03/01",
      endDate: "2020/03/30",
      lecturer: "중계동 척척박사"
    },
    {
      title: "네이버 코딩테스트 대비반",
      img: "naver.png",
      startDate: "2020/04/01",
      endDate: "2020/04/30",
      lecturer: "인도네시아 불주먹"
    },
    {
      title: "백준 기출 문제풀이",
      img: "boj.png",
      startDate: "2020/05/01",
      endDate: "2020/05/30",
      lecturer: "수유리 우동사리"
    },
    {
      title: "소수 유형 알고리즘 특강",
      img: "eratosthenes.png",
      startDate: "2020/06/01",
      endDate: "2020/06/30",
      lecturer: "공릉동 장도리"
    },
    {
      title: "최대공약수 유형 알고리즘 특강",
      img: "euclidean.png",
      startDate: "2020/07/01",
      endDate: "2020/07/30",
      lecturer: "흑석동 메이웨더"
    },
    {
      title: "알고리즘 입출력 완전정복 특강",
      img: "io.png",
      startDate: "2020/08/01",
      endDate: "2020/08/30",
      lecturer: "상도동 얍샙이"
    }
  ];

  @action
  put = title => {
    const curItem = this.courseItems.find(item => item.title === title);
    this.courseItems.remove(curItem);
    this.selectedItems.push(curItem);
  }

  @action
  take = title => {
    const curItem = this.selectedItems.find(item => item.title === title);
    this.selectedItems.remove(curItem);
    this.courseItems.push(curItem);
  }

  @computed
  get total() {
    console.log('장바구니 강좌 수 계산중...');
    return this.selectedItems.length;
  }
}
```

### 2. Provider로 프로젝트에 스토어 적용

원하는 모든 컴포넌트에서 스토어의 값을 사용하기 위해, 프로젝트 엔트리 파일인 index.js에서 Provider 컴포넌트를 사용하자.

**src/index.js**

```javascript
// ...
import { Provider } from 'mobx-react';
import RegisterStore from './store/register';

const register = new RegisterStore();

ReactDOM.render(
  <Provider register={register}>
    <App/>
  </Provider>, document.getElementById('root'));

serviceWorker.unregister();
```

이제 원하는 컴포넌트에서 부모 컴포넌트와 동일한 방법으로 props를 통해 스토어 값을 받아올 수 있다.

### 3. 컴포넌트에 스토어 주입 (inject / observer)

상태 값이 필요한 컴포넌트에서 @inject decorator로 필요한 값을 주입하자. 주입된 값은 위에서 언급한대로 props로 받아올 수 있다.

**src/components/BasketItemList.js**

```javascript
// ...
import { inject, observer } from "mobx-react";

const BasketItemList = ({ items, onTake }) => {
  const itemList = items.map(item => (
    <BasketItem 
      item={item}
      key={item.title}
      onTake={onTake}
    />
  ));
  return <div className="row">{itemList}</div>;
};

export default inject(({ register }) => ({
  items: register.selectedItems,
  onTake: register.take
}))(observer(BasketItemList));
```

**src/components/CourseItemList.js**

```javascript
// ...
import { inject, observer } from 'mobx-react';

const CourseItemList = ({ items, onPut }) => {
  const itemList = items.map(item => 
    <CourseItem 
      item={item} 
      key={item.title} 
      onPut={onPut}
    />
  );
  return <div className="row">{itemList}</div>;
};

export default inject(({ register }) => ({
  items: register.courseItems,
  onPut: register.put,
}))(observer(CourseItemList));

```

**src/components/TotalCount.js**

```javascript
import React, { Fragment } from 'react'
import { inject, observer } from 'mobx-react';

const TotalCount = ({ total }) => {
  return (
    <Fragment>
      { total }
    </Fragment>
  )
}

export default inject(({ register }) => ({
  total: register.total
}))(observer(TotalCount));
```

새로 생성된 TotalCount 컴포넌트도 Registration.js 와 RegistrationTemplate.js에 삽입해주자. 그 외에 몇 가지 변경점이 더 있긴 한데, 여기서 모두 설명하기엔 투머치인 것 같다. [완성 코드](https://github.com/cupjoo/course-registration/tree/5155e9589bb89683b856e6928e9f5102ce0b08a8)에서 변경사항을 확인하자.

## 참고 사이트

> 
- [Redux 또는 MobX 를 통한 상태 관리](https://velog.io/@velopert/series/redux-or-mobx)
- [MobX Documentation](https://mobx.js.org/)
- [React - eject 없이 Mobx 데코레이터 사용하기](https://velog.io/@wlsdud2194/Mobx-데코레이터-yarn-eject-없이-사용하기)
- [우아한 설계의 첫걸음, ES7의 decorator](https://blog-kr.zoyi.co/channel-frontend-decorator/)
