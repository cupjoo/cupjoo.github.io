---
layout: post
title: "C++ STL in 알고리즘"
author: cupjoo
categories: [알고리즘, C++]
image: assets/images/2020-02-06/1.png
---

[대회기출로 정리하는 알고리즘 로드맵](https://cupjoo.github.io/대회기출로-정리하는-알고리즘-로드맵)

---

이번 포스팅도 [Java Collections in 알고리즘](https://cupjoo.github.io/Java-Collections-in-알고리즘)와 동일하게 설명보다는 사용법 위주로 작성하여 Cheetsheet의 용도로 활용할 예정이다. 꼭 필요한 STL만 정리했다.

## STL 이란?

STL은 Standard Template Library의 줄임말로, C++에서 자주 사용되는 함수 및 자료형 Library의 집합을 말한다. STL은 크게 Container (자료구조)와 Iterator (반복자), Algorithm (알고리즘)으로 분류되며, Container는 다시 다음과 같이 분류된다.

- Sequence Container
  - vector
  - stack / queue
  - deque
  - list
  - array (C 배열 X)
- Associative Container
  - set
  - map

### 참고

모든 컨테이너는 기본적으로 포인터와 다르게 레퍼런스가 아닌 값을 제공한다. `(call by value)` 따라서 함수에 인자로 넘길 때는 자동으로 복사본을 생성하기에, 값을 변경시키고 싶다면 & 연산자를 붙여야 한다.

## Vector

벡터는 주로 동적 배열을 표현하는데 사용되는 자료형이다. Java의 ArrayList와 동일하다고 보면 된다.

```cpp
#include <iostream>
#include <vector>
#define N 100
using namespace std;

int main() {
	vector<int> vec;
	// initialize N size vector as -1
	vector<int> vec_s(N, -1);

	for (int i = 1; i <= 5; i++) {
		vec.push_back(i);
	}
	// indexing
	cout << vec[3] << endl;
	cout << vec.front() << endl;
	cout << vec.back() << endl;

	vec.pop_back();
	cout << vec.size() << endl;
	cout << vec.empty() << endl;
	
	return 0;
}
```

다음과 같이 2차원 벡터를 표현할 수도 있다.

```cpp
#include <iostream>
#include <vector>
#define N 100
using namespace std;

int main() {
	vector<vector<int>> vec2(N);
	vector<int> graph[N];

	int arr[4][2] = { {1,2},{2,3},{4,5},{6,7} };
	for (int r = 0; r < 4; r++) {
		for (int c = 0; c < 2; c++) {
			vec2[r].push_back(arr[r][c]);
		}
	}
	
	for (int i = 0; i < 4; i++) {
		int a = arr[i][0], b = arr[i][1];
		graph[a].push_back(b);
		graph[b].push_back(a);
	}

	return 0;
}
```

위에서 언급한대로, 함수 연산 시 실제 값을 변경시키고 싶은 경우 & 연산자를 붙인다.

```cpp
#include <iostream>
#include <vector>
using namespace std;

void increase(vector <int> vec) {
	vec.assign(10, 3);
}
void decrease(vector <int>& vec) {
	vec.assign(10, 1);
}

int main() {
	vector <int> vec(10, 2);

	increase(vec);	// not changed
	for (int i = 0; i < vec.size(); i++) {
		cout << vec[i] << " ";
	}
	cout << "\n";

	decrease(vec);	// changed
	for (int i = 0; i < vec.size(); i++){
		cout << vec[i] << " ";
	}

	return 0;
}
```

### 정리

- ArrayList와 마찬가지로 배열로 대체가 가능하다면 배열을 쓰자.
- `Graph` 표현 시 2차원 벡터를 사용한다.
- 함수에서 실제 값 변경 시 & 연산자를 붙인다.

## Stack

별도의 설명이 필요 없을 것 같다.

```cpp
#include <iostream>
#include <stack>
using namespace std;

int main() {
	stack <int> s;

	s.push(10);
	cout << s.top() << endl;
	cout << s.size() << endl;
	s.pop();
	cout << s.empty() << endl;

	return 0;
}
```

## Queue

마찬가지다.

```cpp
#include <iostream>
#include <queue>
using namespace std;

int main() {
	queue <int> q;

	q.push(10);
	cout << q.front() << endl;
	cout << "size: " << q.size() << endl;
	q.pop();
	cout << q.empty() << endl;

	return 0;
}
```

## Pair

Pair는 2개의 값으로 이루어진 한 쌍의 구조체다. 라이브러리 선언 없이 내장된 자료형이기에 굳이 class나 struct를 새롭게 정의하지 않아도 되서 편리하다. 다음 코드와 동일하다고 보면 된다. 주로 좌표 등을 나타내는데 많이 사용된다.

```cpp
template <class T1, class T2>
struct pair {
  T1 first;
  T2 second;
};
```

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
	vector <pair<int, int>> pos;

	pos.push_back({ 1,3 });
	pos.push_back({ 2,4 });
	for (int i = 0; i < pos.size(); i++) {
		cout << pos[i].first << "," << pos[i].second << '\n';
	}
	return 0;
}
```

## Set

특정 객체의 존재 유무만을 저장하는 컨테이너다. set은 자료를 트리 구조로 정렬해서 저장하기 때문에, 특정 객체 탐색 시 O(log N)의 시간 복잡도가 걸린다. 값의 유무를 확인하는 데 있어 모든 컨테이너 중 가장 빠르지만, 원소를 추가할 때도 O(log N)의 시간이 걸린다. 단, BidirectionalIterator이므로 at과 같은 indexing은 불가능하며, 중복 key를 가질 수 없다. Java에서는 HashSet으로 대체된다.

```cpp
#include <set>
#include <iostream>
using namespace std;

int main() {
	set <int> s;
	for (int i = 1; i < 5; i++) {
		s.insert(i);
	}
	cout << (s.count(2) ? "found!" : "not found");

	return 0;
}
```
  
## Map

set이 key만 저장했다면, map은 key:value 쌍의 pair 객체를 저장하는 컨테이너다. 마찬가지로 중복 key를 저장할 수 없다. 그냥 pair 벡터를 생성하면 되지 않나 싶지만, map도 set과 마찬가지로 트리 구조로 이루어져 있어, 객체 탐색 시 O(log N)의 시간 복잡도가 걸리기에 자료를 찾는 데 있어서는 더 효율적이다. Java에서는 HashMap으로 대체된다.

```cpp
#include <iostream>
#include <string>
#include <map>
using namespace std;

int main() {
	map<string, int> info;

	info.insert({ "최준영", 24 });
	info["최준혁"] = 27;

	for (auto i = info.begin(); i != info.end(); i++) {
		cout << i->first << ": " << i->second << '\n';
	}
	cout << (info.count("최준영") ? "found!" : "not found");

	return 0;
}
```

확실히 set과 map이 성능 면에서는 vector보다 우수하긴 한데, vector가 워낙 만능이다 보니 의도된 문제가 아니라면 vector를 쓰는게 낫다.

## Iterator

iterator는 컨테이너에 보관된 원소에 접근할 수 있는 객체를 말한다. 주로 반복문에 사용되며, 일종의 포인터로 생각하면 된다. 따라서 다음과 같이 * 연산자와 함께 사용할 수 있다.

```cpp
#include <iostream>
#include <map>
#include <vector>
#include <string>
using namespace std;

int main() {
	// vector
	vector <int> vec;
	for (int i = 1; i <= 10; i++) {
		vec.push_back(i);
	}
	for (vector<int>::iterator i = vec.begin(); i < vec.end(); i++) {
		cout << *i << " ";
	}
	cout << '\n';

	// map
	map<string, int> info;
	info.insert({ "최준영", 24 });
	info.insert({ "최준혁", 27 });
	for (map<string,int>::iterator i = info.begin(); i != info.end(); i++) {
		cout << i->first << ": " << i->second << '\n';
	}

	return 0;
}
```

참고로 end() 함수는 마지막 요소의 한 칸 뒤를 가리키니 for문 사용 시 <= 연산자 대신 < 연산자를 사용하자.

  
### 참고

하지만 iterator는 실제로 포인터와는 다르다. 다음 예시를 보자. (iterator는 cout 함수로는 출력이 불가능하기에 printf 함수를 사용했다.)

```cpp
#include <vector>
#define MAXSIZE 100

using namespace std;

int main() {
	vector <int> vec;

	for (int i = 1; i <= 10; i++)
		vec.push_back(i);

	// 주소값 비교
	printf("%d\n", vec);				// iterator 값
	printf("%d\n", vec.begin());		// iterator 값
	printf("%d\n\n", &vec.front());		// vec[0] 주소값
	printf("%d\n", &vec[0]);			// vec[0] 주소값
	printf("%d\n", &vec[1]);			// vec[1] 주소값

	// 값 비교
	printf("%d\n", *vec.begin());		// vec[0] 값
	printf("%d\n", vec[0]);				// vec[0] 값
	printf("%d\n", vec.front());		// vec[0] 값
	printf("%d\n", *(vec.begin()+2));	// vec[2] 값

	return 0;
}
```

벡터는 기본적으로 포인터와 동일하게 indexing이나 \* 연산자를 사용할 수 있지만, iterator 자체의 값은 주소값을 나타내지 않는다. 따라서 해당 iter가 몇 번째인지 출력할 수는 없다. 주의하자! 

## Sort

Algorithm 라이브러리에 포함된 함수로, 설명이 필요 없을 것 같다.

```cpp
#include <algorithm>
#include <vector>
using namespace std;

bool comp(pair<int,int> a, pair<int,int> b) {
	if (a.second == b.second) return a.first < b.first;
	else return a.second > b.second;
}

int main() {
	vector<int> arr;
	vector<pair<int, int>> cnt;

	for (int i = 1; i <= 10; i++) {
		arr.push_back(i);
		cnt.push_back({ i,i+1 });
	}
	sort(arr.begin(), arr.end());
	sort(cnt.begin(), cnt.end(), comp);

	return 0;
}
```

## 참고 사이트

> [passing vectors to a function, value vs reference C++](https://stackoverflow.com/questions/26647152/passing-vectors-to-a-function-value-vs-reference-c)

> [Passing vector to a function in C++](https://www.geeksforgeeks.org/passing-vector-function-cpp/)

> [씹어먹는 C++ - <10 - 3. C++ STL - 알고리즘(algorithm)>](https://modoocode.com/225)

> [C++ 레퍼런스](http://www.cplusplus.com/reference/iterator/)

> [씹어먹는 C++ - <10 - 2. C++ STL - 셋(set), 맵(map), unordered\_set, unordered\_map>](https://modoocode.com/224)
