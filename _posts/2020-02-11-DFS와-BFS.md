---
layout: post
title: "DFS와 BFS"
author: cupjoo
categories: [알고리즘]
image: assets/images/2020-02-11/1.png
hidden: true
---

[대회기출로 정리하는 알고리즘 로드맵](https://cupjoo.github.io/대회기출로-정리하는-알고리즘-로드맵)

---

[[BOJ] 2178 미로 탐색](https://www.acmicpc.net/problem/2178)

![2.gif]({{ site.baseurl }}/assets/images/2020-02-11/2.gif)

![3.png]({{ site.baseurl }}/assets/images/2020-02-11/3.png)

![4.png]({{ site.baseurl }}/assets/images/2020-02-11/4.png)

![5.png]({{ site.baseurl }}/assets/images/2020-02-11/5.png)

![6.png]({{ site.baseurl }}/assets/images/2020-02-11/6.png)

## 선언부

```cpp
typedef struct POT {
	int r, c, dist;
}Pot;

			    // 동 서 남 북 
const int dr[] = { 0, 0, 1, -1 };
const int dc[] = { 1, -1, 0, 0 };
const int MAXN = 100 + 2;

int N, M;
int board[MAXN][MAXN];
bool visit[MAXN][MAXN];	// default false
```

## BFS

```cpp
int bfs() {
	queue<Pot> q;
	q.push({ 0,0,0 });
	visit[nr][nc] = true;

	while (!q.empty()) {
		Pot pot = q.front();
		q.pop();

		if (pot.r == N && pot.c == M) {
			return pot.dist;
		}

		FOR(i, 0, 4) {
			int nr = pot.r + dr[i];
			int nc = pot.c + dc[i];

			if (nr < 0 || nr >= N || nc < 0 || nc >= M)	continue;
			if (board[nr][nc] == 0)	continue;
			if (visit[nr][nc] == true) continue;

			q.push({ nr, nc, pot.dist+1 });
			visit[nr][nc] = true;
		}

	}
	return -1;
}
```

## DFS

```cpp
int dfs(Pot pot) { // { 0,0,0}
	if (pot.r == N && pot.c == M)
		return pot.dist;

	int min_dist = INFINITY;

	FOR(i, 0, 4) {
		int nr = pot.r + dr[i];
		int nc = pot.c + dc[i];
		if (nr < 0 || nr >= N || nc < 0 || nc >= M)	continue;
		if (board[nr][nc] == 0)	continue;
		if (visit[nr][nc] == false) {

			visit[nr][nc] = true;
			min_dist = min(min_dist, dfs({ nr, nc, pot.dist + 1 }));
			visit[nr][nc] = false;
		}
	}
	return (min_dist == INFINITY) ? -1 : min_dist;
}
```

## 기본 개념

## 대회 기출

## 추가 문제

## 출처

> 출처1
